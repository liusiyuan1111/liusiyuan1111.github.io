<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Transformer图像分割论文</title>
      <link href="2021/05/23/09-Transformer%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E8%AE%BA%E6%96%87/"/>
      <url>2021/05/23/09-Transformer%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Transformer图像分割论文"><a href="#Transformer图像分割论文" class="headerlink" title="Transformer图像分割论文"></a>Transformer图像分割论文</h1><p>这篇博客整理使用Transformer来做图像分割的论文，主要是医学图像方向，包括以下几篇文章：</p><ol><li>SETR：<a href="https://arxiv.org/abs/2012.15840">Rethinking Semantic Segmentation from a Sequence-to-Sequence Perspective with Transformers</a></li><li>BoTNet：<a href="https://arxiv.org/abs/2101.11605">Bottleneck Transformers for Visual Recognition</a></li><li>TransFuse：<a href="https://arxiv.org/abs/2102.08005">TransFuse: Fusing Transformers and CNNs for Medical Image Segmentation</a></li><li>Swin-Unet：<a href="https://arxiv.org/abs/2105.05537">Swin-Unet: Unet-like Pure Transformer for Medical Image Segmentation</a></li><li>MedT：<a href="https://arxiv.org/abs/2102.10662">Medical Transformer: Gated Axial-Attention for Medical Image Segmentation</a></li></ol><h2 id="一、SETR-CVPR2021-复旦等提出SETR语义分割网络"><a href="#一、SETR-CVPR2021-复旦等提出SETR语义分割网络" class="headerlink" title="一、SETR|CVPR2021|复旦等提出SETR语义分割网络"></a>一、SETR|CVPR2021|复旦等提出SETR语义分割网络</h2><h3 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h3><p>作者：Sixiao Zheng et al.（复旦大学 &amp; 牛津大学 &amp; 萨里大学 &amp; 腾讯优图 &amp; 脸书）</p><p>文章：<a href="https://arxiv.org/abs/2012.15840">https://arxiv.org/abs/2012.15840</a></p><p>源码：<a href="https://github.com/fudan-zvg/SETR">https://github.com/fudan-zvg/SETR</a></p><h2 id="二、BotNet-Transformer应用CV领域的经典之作"><a href="#二、BotNet-Transformer应用CV领域的经典之作" class="headerlink" title="二、BotNet|Transformer应用CV领域的经典之作"></a>二、BotNet|Transformer应用CV领域的经典之作</h2><h3 id="论文信息-1"><a href="#论文信息-1" class="headerlink" title="论文信息"></a>论文信息</h3><p>作者：Aravind Srinivas  et al.（UC Berkeley, Google Research ）</p><p>文章：<a href="https://arxiv.org/pdf/2101.11605">https://arxiv.org/pdf/2101.11605</a></p><p>源码：<a href="https://github.com/lucidrains/bottleneck-transformer-pytorch">https://github.com/lucidrains/bottleneck-transformer-pytorch</a></p><h2 id="三、TransFuse-融合Transformers和CNN用于医学图像分割"><a href="#三、TransFuse-融合Transformers和CNN用于医学图像分割" class="headerlink" title="三、TransFuse|融合Transformers和CNN用于医学图像分割"></a>三、TransFuse|融合Transformers和CNN用于医学图像分割</h2><h3 id="论文信息-2"><a href="#论文信息-2" class="headerlink" title="论文信息"></a>论文信息</h3><p>作者：Yundong Zhang et al.（佐治亚理工学院 ）</p><p>文章：<a href="https://arxiv.org/pdf/2102.08005">https://arxiv.org/pdf/2102.08005</a></p><h2 id="四、Swin-Unet-首个纯Transformer的医学图像分割网络"><a href="#四、Swin-Unet-首个纯Transformer的医学图像分割网络" class="headerlink" title="四、Swin-Unet|首个纯Transformer的医学图像分割网络"></a>四、Swin-Unet|首个纯Transformer的医学图像分割网络</h2><h3 id="论文信息-3"><a href="#论文信息-3" class="headerlink" title="论文信息"></a>论文信息</h3><p>作者：Hu Cao et al.（慕尼黑工业大学, 复旦大学, 华为）</p><p>文章：<a href="https://arxiv.org/abs/2105.05537">https://arxiv.org/abs/2105.05537</a></p><p>源码：<a href="https://github.com/HuCaoFighting/Swin-Unet">https://github.com/HuCaoFighting/Swin-Unet</a></p><h2 id="五、MedT-医学图像分割新网络"><a href="#五、MedT-医学图像分割新网络" class="headerlink" title="五、MedT|医学图像分割新网络"></a>五、MedT|医学图像分割新网络</h2><h3 id="论文信息-4"><a href="#论文信息-4" class="headerlink" title="论文信息"></a>论文信息</h3><p>作者：Jeya Maria Jose Valanarasu et al.（约翰斯·霍普金斯大学，罗格斯大学）</p><p>文章：<a href="https://arxiv.org/pdf/2102.10662">https://arxiv.org/pdf/2102.10662</a></p><p>源码：<a href="https://github.com/jeya-maria-jose/Medical-Transformer">https://github.com/jeya-maria-jose/Medical-Transformer</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> 遥感图像 </tag>
            
            <tag> Transformer </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>媒体查询+rem布局</title>
      <link href="2021/05/14/08-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2+rem%E5%B8%83%E5%B1%80/"/>
      <url>2021/05/14/08-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2+rem%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="媒体查询-rem布局"><a href="#媒体查询-rem布局" class="headerlink" title="媒体查询+rem布局"></a>媒体查询+rem布局</h2><h3 id="一、rem单位是什么？"><a href="#一、rem单位是什么？" class="headerlink" title="一、rem单位是什么？"></a>一、rem单位是什么？</h3><p>​        rem（font size of the root element)是一个相对单位，指的是相对于根元素的字体大小的单位，常用于移动端布局，使用相对单位的优势在于可以自适应不同分辨率大小的屏幕。要了解rem单位，可以先理解em这个相对单位。</p><h3 id="二、em单位"><a href="#二、em单位" class="headerlink" title="二、em单位"></a>二、em单位</h3><p>​        em单位是最常见的相对长度单位，基准值是当前元素的字号大小（如果当前元素没有设置字号，则继承父元素的字号大小），在css中，1em表示当前元素的字号大小，例如：p元素字号为16px，宽高使用em这个相对单位，则此时宽高应该相对于字号等于16px*10=160px</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 宽高设为10em，由于字号是16px，则此时宽高应为10*16px=160px */</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 10em<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 10em<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到此时的p元素大小为160px*160px</p><p><img src="https://i.loli.net/2021/05/14/hWPOgrf3nHjlMaw.png" alt="image-20210514123306092"></p><h3 id="三、rem单位的使用"><a href="#三、rem单位的使用" class="headerlink" title="三、rem单位的使用"></a>三、rem单位的使用</h3><p>​        在了解什么是em单位和相对单位后，就很好理解rem单位了，em是相对于当前元素字体大小的单位，而rem是相对于根元素的字体大小的单位，根元素也就是html元素。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">html</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 设置根元素的字号为15px */</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">p</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 宽高设为10em，由于根元素字号是15px，则此时宽高应为10*15px=150px */</span>    <span class="token property">width</span><span class="token punctuation">:</span> 10em<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 10em<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2021/05/14/3inN1MWgHhDfAcT.png" alt="image-20210514123618613"></p><h3 id="四、媒体查询"><a href="#四、媒体查询" class="headerlink" title="四、媒体查询"></a>四、媒体查询</h3><p>​        我们已经知道了rem是相对于根元素的字号来说的，那具体怎么适配不同屏幕大小呢？这个时候就要用到媒体查询了，rem一般和媒体查询搭配使用。</p><p>​        媒体查询（Media Query）是CSS3的新语法，使用@media 查询，可以针对不同的媒体类型定义不同的样式，常用于针对不同的设备尺寸设置不同的样式。详细可以浏览mdn：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries/Using_media_queries">使用媒体查询 - CSS（层叠样式表） | MDN (mozilla.org)</a></p><h3 id="五、媒体查询-rem实现大小自适应变化"><a href="#五、媒体查询-rem实现大小自适应变化" class="headerlink" title="五、媒体查询+rem实现大小自适应变化"></a>五、媒体查询+rem实现大小自适应变化</h3><p>​        我们已经知道了rem是相对于根元素大小来说的，也知道了可以通过媒体查询来实现不同的设备尺寸设置不同的样式，那么我们可以通过媒体查询来设置根元素的字号，从而使用rem单位来实现页面元素大小的自适应变化。例如：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">*</span> <span class="token punctuation">&#123;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 媒体查询，当设备宽度大于等于640px时，使用此样式 */</span><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>640px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>    <span class="token selector">html</span> <span class="token punctuation">&#123;</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 媒体查询，当设备宽度大于等于1260px时，使用此样式 */</span><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>1260px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>    <span class="token selector">html</span> <span class="token punctuation">&#123;</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token selector">p</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 根据不同设备尺寸设置了不同的根元素字号 */</span>    <span class="token comment">/* 所以实现不同设备尺寸的屏幕元素大小自适应变化 */</span>    <span class="token comment">/* 没有设置width，则元素宽度由浏览器页面决定 */</span>    <span class="token property">height</span><span class="token punctuation">:</span> 10rem<span class="token punctuation">;</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 1rem<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        此时浏览器页面宽度为861px，当设备宽度大于等于640px时，元素高度应该是50px * 10rem=500px  元素内字体应该是50p * 1rem=50px</p><p><img src="https://i.loli.net/2021/05/14/uHTYnCVc3iSfgqy.png" alt="image-20210514133257112"></p><p>​        此时浏览器页面宽度为1385px，当设备宽度大于等于1260px时，元素高度应该是100px * 10rem=1000px  元素内字体应该是100p * 1rem=100px </p><p><img src="https://i.loli.net/2021/05/14/sm65SnlyqfLxdP1.png" alt="image-20210514133641144"></p><h3 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h3><ol><li>rem常用于移动端布局，PC端很少使用</li><li>rem常和媒体查询搭配使用</li><li>rem是过去移动端适配的一个过渡方式，随着vm/vh/vmax/vmin这种布局方式的兼容性越来越好，已经逐渐取代了rem布局</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> 前端 </tag>
            
            <tag> CSS3 </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文翻译：Deep Image Retrieval  A Survey</title>
      <link href="2021/02/05/07-%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%9ADeep-Image-Retrieval-A-Survey/"/>
      <url>2021/02/05/07-%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%9ADeep-Image-Retrieval-A-Survey/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Image-Retrieval-A-Survey"><a href="#Deep-Image-Retrieval-A-Survey" class="headerlink" title="Deep Image Retrieval: A Survey"></a>Deep Image Retrieval: A Survey</h1><p>深度图像检索综述</p><p><strong>Abstract</strong>—In recent years a vast amount of visual content has been generated and shared from various fields, such as social media platforms, medical images, and robotics. This abundance of content creation and sharing has introduced new challenges. In particular, searching databases for similar content, i.e., content based image retrieval (CBIR), is a long-established research area, and more efficient and accurate methods are needed for real time retrieval. Artificial intelligence has made progress in CBIR and has significantly facilitated the process of intelligent search. In this survey we organize and review recent CBIR works that are developed based on deep learning algorithms and techniques, including insights and techniques from recent papers. We identify and present the commonly-used benchmarks and evaluation methods used in the field. We collect common challenges and propose promising future directions. More specifically, we focus on image retrieval with deep learning and organize the state of the art methods according to the types of deep network structure, deep features, feature enhancement methods, and network fine-tuning strategies. Our survey considers a wide variety of recent methods, aiming to promote a global view of the field of instance-based CBIR.<br><strong>Index Terms</strong>—Content based image retrieval, Deep learning, Convolutional neural networks, Literature survey</p><p><strong>摘要</strong>—近年来，从社交媒体平台、医学图像和机器人技术等各个领域产生并共享了大量视觉内容。这种丰富的内容创建和共享带来了新的挑战。特别是，在数据库中搜索相似的内容，即基于内容的图像检索(CBIR)，是一个由来已久的研究领域，实时检索需要更有效和更准确的方法。人工智能在CBIR取得了进展，极大地促进了智能搜索的进程。在这篇综述中，我们组织和回顾了CBIR最近的工作，这些工作是基于深度学习算法和技术开发的，包括来自最近论文的算法和技术。我们确定并介绍了该领域常用的基准和评估方法。我们收集共同的挑战，并提出有前景的未来研究方向。更具体地说，我们关注具有深度学习的图像检索，并根据深度网络结构、深度特征、特征增强方法和网络微调策略的类型来组织最先进的方法。我们的综述考虑了各种各样的最新方法，旨在促进基于实例的CBIR领域的全球视野。</p><p><strong>索引</strong>—基于内容的图像检索、深度学习、卷积神经网络、文献综述</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a><strong>1 INTRODUCTION</strong></h2><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a><strong>1 引言</strong></h2><p>CONTENT based image retrieval (CBIR) is the problem of searching for semantically matched or similar images in a large image gallery by analyzing their visual content, given a query image that describes the user’s needs. CBIR has been a longstanding research topic in the computer vision and multi-media community [1], [2]. With the present, exponentially increasing, amount of image and video data, the development of appropriate information systems that efficiently manage such large image collections is of utmost importance, with image searching being one of the most indispensable techniques. Thus there is nearly endless potential for applications of CBIR, such as person re-identification [3], remote sensing [4], medical image search [5], and shopping recommendation in online markets [6], among many others.</p><p>基于内容的图像检索(CBIR)是通过分析图像的视觉内容，在大型图像库中搜索语义匹配或相似的图像的问题，给出描述用户需求的查询图像。CBIR一直是计算机视觉和多媒体领域的一个长期研究课题。随着当前图像和视频数据量的指数级增长，开发能够有效管理如此大的图像集合的信息系统是至关重要的，其中图像检索是不可缺少的技术之一。因此，CBIR的应用潜力几乎是无穷无尽的，如行人重识别，遥感图像，医学图像检索，以及在线商城的购物推荐等等。</p><p>A broad categorization of CBIR methodologies depends on the level of retrieval, i.e., instance level and category level. In instance level image retrieval, a query image of a particular object or scene (e.g., the Eiffel Tower) is given and the goal is to find images containing the same object or scene that may be captured under different conditions [7], [8]. In contrast, the goal of category level retrieval is to find images of the same class as the query (e.g., dogs, cars, etc.). Instance level retrieval is more challenging and promising as it satisfies specific objectives for many applications. Notice that we limit the focus of this survey to instance-level image retrieval and in the following, if not further specified, “image retrieval” and “instance retrieval” are considered equivalent and will be used interchangeably. </p><p>CBIR方法的广泛分类取决于检索的级别，即实例级和类别级。在实例级图像检索中，给出特定对象或场景(例如，埃菲尔铁塔)的查询图像，并且目标是找到包含在不同条件下可能被捕获的相同对象或场景的图像。相比之下，类别级检索的目标是找到与查询相同类别的图像(例如，狗、汽车等))。实例级检索更具挑战性和前景，因为它满足了许多应用程序的特定目标。注意我们将本次综述的重点限于实例级图像检索，在下文中，如果没有进一步说明，“图像检索”和“实例检索”被认为是等效的，将可互换使用。</p><p>Finding a desired image can require a search among thousands, millions, or even billions of images. Hence, searching efficiently is as critical as searching accurately, to which continued efforts have been devoted [7], [8], [9], [10], [11].To enable accurate and efficient retrieval of massive image collections,compact yet rich feature representations are at the core of CBIR.</p><p>找到想要的图像可能需要在数千、数百万甚至数十亿张图像中进行搜索。因此，有效的搜索和精确的搜索一样重要，对此人们一直在努力，参考文献7-11。为了准确高效地检索大量图像集合，紧凑而丰富的特征表示是CBIR的核心。</p><p>In the past two decades, remarkable progress has been made in image feature representations, which mainly consist of two important periods: feature engineering and feature learning (particularly deep learning). In the feature engineering era (i.e., pre-deep learning), the field was dominated by milestone hand-engineered feature descriptors, such as the Scale-Invariant Feature Transform (SIFT) [19]. The feature learning stage, the deep learning era since 2012, begins with artificial neural networks, particularly the breakthrough ImageNet and the Deep Convolutional Neural Network (DCNN) AlexNet [20]. Since then, deep learning has impacted a broad range of research areas, since DCNNs can learn powerful feature representations with multiple levels of abstraction directly from data. Deep learning techniques have attracted enormous attention and have brought about considerable breakthroughs in many computer vision tasks, including image classification [20], [21], [22], object detection [23], and image retrieval [10], [13], [14].</p><p>在过去的二十年里，图像特征表示取得了显著的进展，主要包括两个重要阶段:特征工程和特征学习(特别是深度学习)。在特征工程时代(即深度学习前)，该领域由里程碑式的手工工程特征描述符主导，如尺度不变特征变换(SIFT) 。特征学习阶段，自2012年以来的深度学习时代，始于人工神经网络，特别是突破性的ImageNet和深度卷积神经网络(DCNN) AlexNet  。从那以后，深度学习影响了广泛的研究领域，因为数据挖掘神经网络可以直接从数据中学习具有多层次抽象的强大特征表示。深度学习技术已经引起了极大的关注，并在许多计算机视觉任务中带来了相当大的突破，包括图像分类、对象检测和图像检索。</p><p>Excellent surveys for traditional image retrieval can be found in [1], [2], [8]. This paper, in contrast, focuses on deep learning based methods. A comparison of our work with other published surveys [8], [14], [15], [16] is shown in Table 1. Deep learning for image retrieval is comprised of the essential stages shown in Figure 1 and various methods, focusing on one or more stages, have been proposed to improve retrieval accuracy and efficiency. In this survey, we include comprehensive details about these methods, including feature fusion methods and network fine-tuning strategies etc. , motivated by the following questions that have been driving research in this domain:</p><p>传统图像检索的方法可以在综述[1]、[2]、[8]中找到。相比之下，本文侧重于基于深度学习的方法。我们的工作与其他已发表的综述[8]、[14]、[15]、[16]的比较见表1。图像检索的深度学习由图1所示的基本阶段组成，并且已经提出了各种方法，集中在一个或多个阶段，以提高检索的准确性和效率。在本篇综述中，包括了这些方法的综合细节，特征融合方法和网络微调策略等，其动机是推动该领域研究的以下问题:</p><ol><li>By using off-the-shelf models only, how do deep features outperform hand-crafted features?</li><li>In case of domain shifts across training datasets, how can we adapt off-the-shelf models to maintain or even improve<br>retrieval performance?</li><li>Since deep features are generally high-dimensional, how can we effectively utilize them to perform efficient image<br>retrieval, especially for large-scale datasets?</li></ol><p>1)仅使用现成的模型，深度特征如何胜过手工制作的特征？</p><p>2)在跨训练数据集的领域转移的情况下，我们如何适应现成的模型来保持甚至提高检索性能？</p><p>3)由于深度特征通常是高维的，我们如何有效地利用它们来执行高效的图像检索，尤其是对于大规模数据集。</p><p>TABLE 1: A summary and comparison of the primary surveys in the field of image retrieval.</p><p>表1:图像检索领域主要综述文献的总结和比较。</p><p><img src="https://i.loli.net/2021/02/05/bM8DLriRHAEPGvU.png" alt="image-20210205203313875"></p><p><img src="https://i.loli.net/2021/02/05/U36pBOD87Ckujrd.png" alt="image-20210205203545671"></p><p>Fig. 1: In deep image retrieval, feature embedding and aggregation methods are used to enhance the discrimination of deep features. Similarity is measured on these enhanced features using Euclidean or Hamming distances.</p><p>图1:在深度图像检索中，使用特征嵌入和聚集方法来增强深度特征的区分度。使用欧几里德距离或汉明距离来测量这些增强特征的相似性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 论文翻译 </tag>
            
            <tag> 图像检索 </tag>
            
            <tag> Paper </tag>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10+Linux(manjaro)双系统安装</title>
      <link href="2021/01/17/06-win10-Linux-manjaro-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
      <url>2021/01/17/06-win10-Linux-manjaro-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><code>Manjaro</code>是一款基于Arch Linux的、用户友好的发行版，虽然<code>Manjaro is not Arch</code>，但它依然能够从<code>AUR(Arch User Repository)</code>中提取软件包，且有自己的独立库。</p><p>它有且不仅有如下特性：</p><ul><li><strong>Pre-installed</strong> （在你还没正式安装时，你便可从启动盘直接流畅体验它的桌面系统）</li><li>快、强、高效</li><li>滚动发布，无需定期更新系统版本</li><li>……</li></ul><p>官方网站：<a href="https://manjaro.org/">https://manjaro.org/</a></p><p>本教程仅适用于 <strong>单硬盘 UEFI+GPT格式启动方式</strong></p><h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><h3 id="1-查看电脑的启动方式"><a href="#1-查看电脑的启动方式" class="headerlink" title="1. 查看电脑的启动方式"></a>1. 查看电脑的启动方式</h3><p>目前主流的两种启动系统的方式：<br><strong>legacy</strong>启动+<strong>MBR</strong>分区表</p><p><strong>UEFI</strong>启动+<strong>GPT</strong>分区表</p><p>我们需要查看自己硬盘使用的哪种分区：</p><p>文件资源管理器-&gt;（右键）此电脑-&gt;管理-&gt;磁盘管理</p><p><img src="https://i.loli.net/2021/01/17/9A4NmofOsgHFqrX.png" alt="image-20210117192447505"></p><p>可以看到只有一个磁盘0，所以是“单硬盘”</p><p>右键选择一个磁盘-&gt;属性-&gt;卷<br>在磁盘分区形式一栏中可以看到是GPT or MBR，我的是GPT分区</p><p><img src="https://i.loli.net/2021/01/17/p71h9fNE4mxueqy.png" alt="image-20210117192601275"></p><h3 id="2-下载manjaro镜像："><a href="#2-下载manjaro镜像：" class="headerlink" title="2.下载manjaro镜像："></a>2.下载manjaro镜像：</h3><p>在官网下载可能速度会比较慢，可以选择在<a href="https://mirrors.tuna.tsinghua.edu.cn/osdn/storage/g/m/ma/manjaro/kde/">清华大学开源软件镜像站</a>下载</p><p><img src="https://i.loli.net/2021/01/17/DVi4aSotkdhUw8m.png" alt="image-20210117192811144"></p><p><img src="https://i.loli.net/2021/01/17/ABOYwcg8zmCI6Ps.png" alt="image-20210117192840115"></p><p>我这里选择了20.1.1下载。</p><h3 id="3-制作启动盘"><a href="#3-制作启动盘" class="headerlink" title="3. 制作启动盘"></a>3. 制作启动盘</h3><p>制作启动盘有很多种方法，我这里选择使用<a href="http://rufus.ie/">Rufus</a>来制作</p><p><img src="https://i.loli.net/2021/01/17/z4Jkx23AiV5TBgS.png" alt="image-20210117193028900"></p><p>下载完成之后插入U盘，打开rufus软件，选择下载好的镜像，点击开始即可</p><p><img src="https://i.loli.net/2021/01/17/5igl7EAmPByWYTj.png" alt="image-20210117193245582"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> 系统安装 </tag>
            
            <tag> Linux </tag>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git多分支管理博客</title>
      <link href="2021/01/17/05-%E4%BD%BF%E7%94%A8git%E5%A4%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/01/17/05-%E4%BD%BF%E7%94%A8git%E5%A4%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>最近使用GitHub page+Hexo搭建了一个独立博客，有一个小问题，现在只能在自己这台电脑上写博客，换一台电脑就无法使用了，所以在网上找了一下教程，最后决定通过git分支来进行多终端工作，具体教程如下：</p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>首先需要明白的是，通过hexo d上传部署到GitHub的其实是hexo编译之后的文件，用来生成网页的，并不包含源文件</p><p><img src="https://i.loli.net/2021/01/17/XVlwK8WrsH3oCcE.png" alt="image-20210117172156337"></p><p>只有本地目录下自动生成的.deploy_git文件夹会被上传到GitHub，而其他的配置文件，主题文件和写在post的博客都是没有上传到GitHub的</p><p><img src="https://i.loli.net/2021/01/17/2NPHxu9wvnpr7IV.png" alt="image-20210117172503099"></p><p><img src="https://i.loli.net/2021/01/17/71RDuQgTSVapNjM.png" alt="image-20210117172324582"></p><p>知道了这个机制，我们就可以利用git的分支管理，把源文件上传到GitHub的另一个分支即可。</p><h2 id="上传分支"><a href="#上传分支" class="headerlink" title="上传分支"></a>上传分支</h2><ol><li>首先在仓库下新建一个hexo分支</li></ol><p><img src="https://i.loli.net/2021/01/17/n6hZ3zg4tY7QsIx.png" alt="image-20210117173409933"></p><ol start="2"><li>在setting里更改hexo为默认分支</li></ol><p><img src="https://i.loli.net/2021/01/17/lnQr34VD5iUYufw.png" alt="image-20210117173443554"></p><ol start="3"><li><p>在本地目录打开git bash，将仓库clone到本地，此时默认分支是hexo，所以clone时只clone了hexo。在本地目录打开clone下来的文件夹，把除了.git文件夹以外的所有文件全部删除。</p><p><img src="https://i.loli.net/2021/01/17/emEt35SnNvouF2X.png" alt="image-20210117174348551"></p></li><li><p>然后把博客源文件全部复制过来，除了.deploy_git。</p><p>注意1：复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话可以自己新建一个，写入以下的内容：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.DS_StoreThumbs.dbdb.json*.lognode_modules&#x2F;public&#x2F;.deploy*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意2：theme主题文件夹中的.git文件夹也要删掉，所以需要显示隐藏文件，检查一下有没有，否则上传的时候会出错</p></li><li><p>提交commit，然后push，打开GitHub看一下是否已经正确上传，此时hexo分支下是这些源文件了。</p></li></ol><p><img src="https://i.loli.net/2021/01/17/ZopbY8mNtWkhRBP.png" alt="image-20210117175409885"></p><h2 id="更换电脑操作"><a href="#更换电脑操作" class="headerlink" title="更换电脑操作"></a>更换电脑操作</h2><p>此时和之前的环境搭建差不多</p><ol><li><p>在新的电脑上安装git，然后设置全局邮箱和用户名，设置ssh key，详细步骤见之前的博文</p><p><a href="https://liusiyuan.site/2021/01/11/GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">GitHub+Hexo搭建个人博客 (liusiyuan.site)</a></p></li><li><p>安装node.js和hexo，但是注意，此时不用hexo init</p></li><li><p>直接在任意目录下git clone即可</p></li><li><p>进入到clone的文件夹中，执行</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">npm installnpm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>然后生成，部署</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">hexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>然后就可以写博客了</p><pre class="line-numbers language-none"><code class="language-none">hexo new newpage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><ol start="7"><li>注意，最好每次写完可以同步上传到GitHub上</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5融媒体制作竞赛团队操作教程</title>
      <link href="2021/01/13/04-HTML5%E8%9E%8D%E5%AA%92%E4%BD%93%E5%88%B6%E4%BD%9C/"/>
      <url>2021/01/13/04-HTML5%E8%9E%8D%E5%AA%92%E4%BD%93%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5融媒体制作竞赛团队操作教程"><a href="#HTML5融媒体制作竞赛团队操作教程" class="headerlink" title="HTML5融媒体制作竞赛团队操作教程"></a>HTML5融媒体制作竞赛团队操作教程</h1><p>这是一个用于广东工贸职业技术学院的软件工程系参加HTML5融媒体内容制作职业技能大赛的教程资料，主要是关于如何使用GitHub管理项目，托管代码。</p><p>团队仓库：<a href="https://github.com/liusiyuan1111/HTML5">liusiyuan1111/HTML5 (github.com)</a></p><p>该仓库主要用于存放学习资料，和同学的项目代码。</p><h2 id="创建一个GitHub账号"><a href="#创建一个GitHub账号" class="headerlink" title="创建一个GitHub账号"></a>创建一个GitHub账号</h2><ol><li><p>创建账号，此步骤省略</p></li><li><p>下载一个GitHub桌面客户端，下载链接<a href="https://desktop.github.com/">GitHub Desktop | Simple collaboration from your desktop</a></p></li></ol><h2 id="clone仓库到本地"><a href="#clone仓库到本地" class="headerlink" title="clone仓库到本地"></a>clone仓库到本地</h2><ol><li><p>fork到自己的仓库</p><p><img src="https://i.loli.net/2021/01/14/moCZsLJ1MIPacKG.png" alt="image-20210114175326921"></p></li><li><p>fork之后可以在自己的Repositories中看到这个仓库</p></li><li><p>在GitHub桌面版登录自己的账号，然后选择<code>Clone a repository from the Internet</code>,把fork的HTML5仓库clone到本地</p></li><li><p>clone时选择第一个<code>To contribute to the parent project</code>,这样就可以pull requests到团队的仓库</p><p><img src="https://i.loli.net/2021/01/14/RkTFEKSMGAHgcPL.png" alt="image-20210114180309546"></p></li><li><p>clone之后可以在本地看到整个仓库的文件夹</p><p><img src="https://i.loli.net/2021/01/14/xQIpodYi1L8B2Rm.png" alt="image-20210114180705376"></p></li><li><p>在学生项目文件夹内，以自己的名字创建一个文件夹，然后在该文件夹内创建两个文件夹，一个是学习，用于存放平时练习的代码；另一个是项目，用来存放练习竞赛的项目代码。</p><p><img src="https://i.loli.net/2021/01/14/AuSfkMHitajzvNq.png" alt="image-20210114180834949"></p></li><li><p>创建好文件夹后，在两个文件夹内分别放入两个文档，一个用于记录学习的情况，一个用于记录项目的情况，可以使用txt格式或者doc格式，建议使用markdown格式（空文件夹无法提交到仓库，所以需要在两个文件夹里分别创建这两个文档，文档里可以不用写任何东西，之后我会告诉大家怎么写文档）</p><p><img src="https://i.loli.net/2021/01/14/EhMUVwcxz16oCup.png" alt="image-20210114181217448"></p><p><img src="https://i.loli.net/2021/01/14/Xyz82bPfnckriYF.png" alt="image-20210114181234619"></p></li><li><p>把自己写的代码分别放入这两个文件夹，然后打开GitHub桌面版，可以在Changes里看到你所做的改动，“+号”（绿色）表示你新增的内容，“-号”（红色）表示你删除的内容</p></li></ol><p>   <img src="https://i.loli.net/2021/01/14/O9Uc6BLWps3tjyv.png" alt="image-20210114181753268"></p><ol start="9"><li><p>在Summary里（必填）可以填入自己的姓名和提交时间，在Description里可以填写此次提交的简要说明（比如：完成了项目1），然后点击<code>commit to main</code></p><p><img src="https://i.loli.net/2021/01/14/1os7vka8wpHPbih.png" alt="image-20210114181828830"></p></li><li><p>然后把写好的代码，提交到原始仓库</p><p><img src="https://i.loli.net/2021/01/14/UnfkYL9XmzHBclo.png" alt="image-20210114181939936"></p></li><li><p>提交之后可以在自己的仓库看到提交的内容，但是原始仓库需要我同意合并才能看到。</p><p><img src="https://i.loli.net/2021/01/14/J8yMPUY64tR7jnb.png" alt="image-20210114182104304"></p></li><li><p>注意，把仓库clone到本地之后，只在自己创建的文件夹内操作，不要随意删除其他的内容</p></li><li><p>大家先按照这个流程练习一次，自己创建文件夹和空白文档。参赛同学必须完成，其他同学随意。</p></li></ol><h2 id="与源仓库同步"><a href="#与源仓库同步" class="headerlink" title="与源仓库同步"></a>与源仓库同步</h2><p>现在大家都已经在仓库里创建了自己的文件夹，但是大家fork的时间不同，clone的仓库也是不同时间点的仓库，如何保持自己的仓库和源仓库保持一致呢。在这里给大家介绍一种比较简单的，无需命令行的教程，方便大家操作。</p><p>简单来说与源仓库保持同步就是反向的pull request，通过对比你现在的仓库和源仓库来实现更新与同步。</p><p>操作步骤如下</p><ol><li><p>在Branch里选择<code>create pull request</code><img src="https://i.loli.net/2021/01/18/HjrXZI7ABGDbuPL.png" alt="image-20210118192712571"></p></li><li><p>会跳到网页版，查看交叉对比你的仓库和源仓库发生的变化。在这里调换顺序，左边选择你的仓库，右边选择源仓库</p><p><img src="https://i.loli.net/2021/01/18/8WecKGuQxOjZdvM.png" alt="image-20210118192845940"></p></li><li><p>更换顺序之后，就会出现上次fork之后，源仓库发生的所有变化，在这里点击<code>create pull request</code></p><p><img src="https://i.loli.net/2021/01/18/g6ex42kmAWh38qD.png" alt="image-20210118193025291"></p></li><li><p>填写必要的信息，然后继续<code>create pull request</code><img src="C:/Users/lsy/AppData/Roaming/Typora/typora-user-images/image-20210118193142529.png" alt="image-20210118193142529"></p></li><li><p>在新的页面，<code>merge pull request</code>合并这些发生更改的请求即可<img src="https://i.loli.net/2021/01/18/7IqOPrtiJ641CNE.png" alt="image-20210118193316198"></p></li><li><p><code>confirm merge</code> 确认合并</p><p><img src="https://i.loli.net/2021/01/18/k8Jdqz7bTMBDvio.png" alt="image-20210118193356274"></p></li><li><p>此时你的仓库里就有了上次fork以后，源仓库更新的内容</p></li><li><p>回到GitHub桌面版，<code>fetch origin</code> 更新</p><p><img src="https://i.loli.net/2021/01/18/TQPBE1pfS3OjW27.png" alt="image-20210118193458922"></p></li><li><p>可以看到相比之前有了17个commit的改变，pull origin 下载这些请求即可</p><p><img src="https://i.loli.net/2021/01/18/Ma34Q7bjLzOTkWh.png" alt="image-20210118193647902"></p></li><li><p>之后每次更新就不用这么麻烦了，只要在Branch里选择 <code>merge into current branch</code></p><p><img src="https://i.loli.net/2021/01/18/wA4m8kRM3jgU2VW.png" alt="image-20210118194043521"></p></li><li><p>选择下面这个分支，然后merge合并</p><p><img src="https://i.loli.net/2021/01/18/E1G5kJYxLQt2jlR.png" alt="image-20210118194150229"></p></li><li><p>最后push更新到你的仓库即完成了更新</p><p><img src="https://i.loli.net/2021/01/18/5NTspa7dF3eQYnB.png" alt="image-20210118194255291"></p></li><li><p>第一次更新需要完成1-9步。之后的每次更新只要完成10-12步即可。</p></li><li><p>除了上述使用GitHub反向pull request来完成与源仓库的同步更新以外，还可以通过git来实现，这里就不详细介绍了，有兴趣了解git的同学可以去学习一下，可以参考以下教程：</p><p><a href="https://lewis.blog.csdn.net/article/details/64440602?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">fork分支与源分支同步代码_lewis-CSDN博客</a></p><p><a href="https://www.jianshu.com/p/79454cf00945">github使用 - 简书 (jianshu.com)</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> 融媒体 </tag>
            
            <tag> web </tag>
            
            <tag> 前端 </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql安装与环境配置教程</title>
      <link href="2021/01/12/03-MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
      <url>2021/01/12/03-MySql%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql安装与环境配置教程"><a href="#MySql安装与环境配置教程" class="headerlink" title="MySql安装与环境配置教程"></a>MySql安装与环境配置教程</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1368756097&auto=1&height=66"></iframe><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p><p>这篇博文主要是安装与配置MySql的详细步骤。</p><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>MySql有免费的版本也有收费的版本，这里选择MySql的免费版本，也就是社区版下载，链接：<a href="https://downloads.mysql.com/archives/community/">MySQL :: Download MySQL Community Server (Archived Versions)</a></p><p>点开后可以看到这个界面，Product Version选择版本，这里选择最新的8.0.21，操作系统选择windows，安装包选择第一个稳定版本。</p><p><img src="https://i.loli.net/2021/01/12/m9bgoEMwDNxdK4A.png" alt="image-20210112162635970"></p><p>下载完成后，把安装包放到放在指定位置，并解压，<strong>注意路径中不要有中文</strong></p><p><img src="https://i.loli.net/2021/01/12/3MCTHbEqSKIF4V1.png" alt="image-20210112163438586"></p><h2 id="MySql安装"><a href="#MySql安装" class="headerlink" title="MySql安装"></a>MySql安装</h2><h3 id="安装MySQL的服务"><a href="#安装MySQL的服务" class="headerlink" title="安装MySQL的服务"></a>安装MySQL的服务</h3><p>以管理员身份打开命令行，因为我这里是放在D盘，所以先进入D盘</p><p><img src="https://i.loli.net/2021/01/12/gxiDAUmMQ1uve5P.png" alt="image-20210112164459773"></p><p>然后进入mysql的bin目录</p><p><img src="https://i.loli.net/2021/01/12/PfzQ2ywYx8Spc1j.png" alt="image-20210112164554951"></p><p>然后执行安装MySQL的服务：</p><pre class="line-numbers language-none"><code class="language-none">mysqld --install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现Service successfully installed的提示，表示安装成功</p><h3 id="初始化MySQL"><a href="#初始化MySQL" class="headerlink" title="初始化MySQL"></a>初始化MySQL</h3><p>使用以下代码初始化MySQL，然后会产生一个随机密码，记住这个密码，以后会遇到</p><pre class="line-numbers language-none"><code class="language-none">mysqld --initialize --console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2021/01/12/X6lL1VGJaKWygcD.jpg" alt="微信图片编辑_20210112165801"></p><h3 id="开启MySQL的服务"><a href="#开启MySQL的服务" class="headerlink" title="开启MySQL的服务"></a>开启MySQL的服务</h3><pre class="line-numbers language-none"><code class="language-none">net start mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2021/01/12/cxd4WsnElwmGB9F.png" alt="image-20210112165929472"></p><h3 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h3><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2021/01/12/r4wmMBPFKc5oTbX.png" alt="image-20210112170159522"></p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><pre class="line-numbers language-none"><code class="language-none">alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;你的密码&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2021/01/12/coGptdW3NlxXMzu.png" alt="image-20210112170435900"></p><h3 id="再次登录验证密码"><a href="#再次登录验证密码" class="headerlink" title="再次登录验证密码"></a>再次登录验证密码</h3><p><img src="https://i.loli.net/2021/01/12/jqUc7yrXBzZTH9P.png" alt="image-20210112170713439"></p><h2 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h2><p>为了方便登录操作mysql，需要设置一个全局变量。</p><p>点击“计算机”-“属性”-“高级系统设置”-“环境变量”</p><p><img src="https://i.loli.net/2021/01/12/aW6CLhfxDwsvdXS.png" alt="image-20210112170852791"></p><p><img src="https://i.loli.net/2021/01/12/JHNaqKUwAjzl6eV.png" alt="image-20210112171441077"></p><p>把mysql变量添加到path路径变量中，点击确定，即可完成<img src="https://i.loli.net/2021/01/12/yP5jAIBSc4lEKqQ.png" alt="image-20210112172214333"></p><p>此时配置完成，当需要命令行使用mysql时，只需要打开cmd，之后输入登录sql语句即可。</p><p><img src="https://i.loli.net/2021/01/12/tycT48kWSxFjNZd.png" alt="image-20210112172502950"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> MySql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo搭建个人博客</title>
      <link href="2021/01/11/02-GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/01/11/02-GitHub+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="GitHub-Hexo搭建个人博客"><a href="#GitHub-Hexo搭建个人博客" class="headerlink" title="GitHub+Hexo搭建个人博客"></a>GitHub+Hexo搭建个人博客</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=863073353&auto=1&height=66"></iframe><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>这里我把个人博客托管在 GitHub Pages 上。GitHub Pages 是一种静态站点托管服务，每个 GitHub 帐户或组织都可以有一个站点。</p><h2 id="Github-Pages上创建博客"><a href="#Github-Pages上创建博客" class="headerlink" title="Github Pages上创建博客"></a>Github Pages上创建博客</h2><h3 id="GitHub创建仓库"><a href="#GitHub创建仓库" class="headerlink" title="GitHub创建仓库"></a>GitHub创建仓库</h3><p>新建一个名为 用户名.github.io的仓库，比如我的GitHub用户名为<code>liusiyuan1111</code> ，那么就新建一个 <code>liusiyuan1111.github.io</code> 的仓库，这样我的网站访问地址就是 <a href="https://liusiyuan1111.github.io/">https://liusiyuan1111.github.io</a> 。</p><p>创建成功后，打开网址，此时显示404</p><p><img src="https://i.loli.net/2021/01/11/RlYJ6xDaZyp8grt.png" alt="image-20210111205132097"></p><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>安装Hexo前需要有Node.Js的环境，安装步骤省略</p><p>Node.js 安装包及源码下载地址为：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>有了nodejs的环境后，就可以安装hexo</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Hexo初始化"><a href="#Hexo初始化" class="headerlink" title="Hexo初始化"></a>Hexo初始化</h3><p>在想要的路径下新建一个文件夹，比如我的是D:\hexo ，这个文件夹内就是你的Hexo博客的源文件，在这个文件夹下右键单击鼠标，点击 Git Bash Here，依次输入以下 npm 命令即可初始化。</p><pre class="line-numbers language-none"><code class="language-none">hexo initnpm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入以上命令后，hexo 会自动下载一些文件到这个目录，包括 <code>node_modules</code>，其中比较重要的几个文件的目录结构如下：</p><pre class="line-numbers language-none"><code class="language-none">.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：hexo 有 2 个<code>_config.yml</code> 文件，一个是站点根目录下的<code>_config.yml</code>，一个是 theme（主题）下的<code>_config.yml</code> 文件。</p><p>博客生成、预览：</p><pre class="line-numbers language-none"><code class="language-none">hexo g # 生成hexo s # 启动服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行以上命令之后，hexo 就会在 public 文件夹生成相关 html 文件，这些就是你博客的静态文件，后续需要把这些提交到 GitHub 上。</p><p><code>hexo s</code> 是开启本地预览服务，打开浏览器访问 <code>http://localhost:4000</code> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故。</p><p><img src="https://i.loli.net/2021/01/11/di1oyQeEmbC5gRA.png" alt="image-20210111215225751"></p><p><img src="https://i.loli.net/2021/01/11/GwLBhxZ1f4Jgei8.png" alt="image-20210111215142547"></p><p>按ctrl+c关闭本地服务器。</p><p><strong>我们以后常用到的Hexo命令：</strong></p><ul><li>hexo s等价于 hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</li><li>hexo g 等价于 hexo generate #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)</li><li>hexo d 等价于 hexo deploy #将本地数据部署到远端服务器(如github)</li><li>hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</li></ul><h2 id="链接Github与本地"><a href="#链接Github与本地" class="headerlink" title="链接Github与本地"></a>链接Github与本地</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>右键单击鼠标，点击 Git Bash Here输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name &quot;Name&quot;git config --global user.email &quot;Email&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Name和Email是我们注册Github时的用户名和邮箱。</strong></p><p>然后生成密钥：</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C &quot;Email&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Email是我们注册Github时的邮箱</strong></p><p>然后会出现：</p><pre class="line-numbers language-none"><code class="language-none">Generating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa):&#x2F;&#x2F;到这里可以直接回车将密钥按默认文件进行存储<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>回车之后：</p><pre class="line-numbers language-none"><code class="language-none">Enter passphrase (empty for no passphrase):&#x2F;&#x2F;这里是要你输入密码，其实不需要输什么密码，直接回车就行Enter same passphrase again:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来会有：</p><pre class="line-numbers language-none"><code class="language-none">Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa.Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa.pub.The key fingerprint is:这里是各种字母数字组成的字符串，结尾是你的邮箱The key&#39;s randomart image is:这里也是各种字母数字符号组成的字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在密钥已经生成，一般存放在（/c/Users/you/.ssh/id_rsa.pub.），我们运行下面的命令将密钥复制为粘贴板：</p><pre class="line-numbers language-none"><code class="language-none">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2021/01/11/FGz8qAbODEsSfti.png" alt="image-20210111212538215"></p><h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><p>在Github头像下面点击Settings，再点击SSH and GPG keys，新建一个SSH，名字任意。</p><p>然后将刚才复制的密钥添加就可以了，像这样：</p><p><img src="https://i.loli.net/2021/01/11/JZwLOSPWeG4MpCr.png" alt="image-20210111212701304"></p><p><strong>本地连接Github</strong></p><p>右键单击鼠标，点击 Git Bash Here输入以下命令，如果如下图所示，出现你的用户名，那就成功了</p><pre class="line-numbers language-none"><code class="language-none">ssh -T git@github.com&#x2F;&#x2F;注意不要做任何修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2021/01/11/JYnibqIWA3ed2kx.png" alt="image-20210111212935613"></p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，我们需要修改一下才能连接Github。</p><p><img src="https://i.loli.net/2021/01/11/Z8PokJyKAX6v9lB.png" alt="image-20210111213124756"></p><p>修改最后一行的配置：</p><pre class="line-numbers language-none"><code class="language-none"># Deployment\## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: &#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改为：</p><pre class="line-numbers language-none"><code class="language-none"># Deployment\## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: &#39;git&#39; repository: git@github.com:liusiyuan1111&#x2F;liusiyuan1111.github.io.git branch: master <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li><strong>repository修改为你自己的github项目地址</strong>。</li><li><strong>每一个冒号后面都有一个空格。</strong></li></ul><p>直接部署一般会报如下错误：</p><pre class="line-numbers language-none"><code class="language-none">Deployer not found: git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为缺少了一个插件，我们可以通过如下命令安装：</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后输入 <code>hexo d</code> 就会将本次有改动的代码全部提交。</p><h2 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h2><p>打开hexo安装目录，我的是D:\Blog\source_posts ，可以发现里面有一个<code>hello-world.md</code>的文件，可以把自己写的md文件直接放进来</p><p><img src="https://i.loli.net/2021/01/11/rgTiDvU6xfYMEqz.png" alt="image-20210111220734944"></p><p>然后hexo g生成静态网页，hexo s可以本地预览效果，最后hexo d部署到GitHub即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/11/01-hello-world/"/>
      <url>2021/01/11/01-hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World!</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=385322&auto=1&height=66"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
